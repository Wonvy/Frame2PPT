<h2>Rectangle Creator</h2>
<p>
  <label for="count">Count:</label>
  <input id="count" type="number" value="5" placeholder="Enter number of rectangles">
</p>
<button id="create">Create</button>
<button id="export">导出为PPT</button>
<button id="cancel">Cancel</button>
<script src="https://unpkg.com/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
<script>

document.getElementById('create').onclick = () => {
  const textbox = document.getElementById('count');
  const count = parseInt(textbox.value, 10);
  parent.postMessage({ pluginMessage: { type: 'create-shapes', count } }, '*')
}

document.getElementById('export').onclick = () => {
  parent.postMessage({ pluginMessage: { type: 'export-to-ppt' } }, '*')
}

document.getElementById('cancel').onclick = () => {
  parent.postMessage({ pluginMessage: { type: 'cancel' } }, '*')
}

// 处理从插件接收到的导出数据
window.onmessage = async (event) => {
  const message = event.data.pluginMessage;
  
  if (message.type === 'export-data') {
    try {
      // @ts-ignore
      const pptx = new PptxGenJS();
      
      // 设置PPT尺寸比例
      const { width, height } = message.aspectRatio;
      const widthInches = Math.max(1, width / 72);
      const heightInches = Math.max(1, height / 72);
      
      pptx.defineLayout({ 
        name: 'CUSTOM',
        width: widthInches,
        height: heightInches
      });
      pptx.layout = 'CUSTOM';
      
      // 为每个Frame创建一个幻灯片
      for (const frameData of message.data) {
        const slide = pptx.addSlide();
        
        // 处理每个元素
        for (const element of frameData.elements) {
          const x = Math.max(0, element.x / 72);
          const y = Math.max(0, element.y / 72);
          const w = Math.max(0.1, element.width / 72);
          const h = Math.max(0.1, element.height / 72);

          if (element.type === 'TEXT' && element.characters.trim()) {
            // 处理文本颜色
            let textColor = '000000';
            let textOpacity = 100;
            if (element.fills && element.fills.length > 0) {
              const fill = element.fills[0];
              if (fill.type === 'SOLID') {
                textColor = `${Math.round(fill.color.r * 255).toString(16).padStart(2, '0')}${Math.round(fill.color.g * 255).toString(16).padStart(2, '0')}${Math.round(fill.color.b * 255).toString(16).padStart(2, '0')}`;
                if ('opacity' in fill) {
                  textOpacity = Math.round(fill.opacity * 100);
                }
              }
            }

            // 处理字体名称
            const fontName = element.fontName.family;
            const fontStyle = element.fontName.style;
            const fullFontName = fontStyle === 'Regular' ? fontName : `${fontName} ${fontStyle}`;

            slide.addText(element.characters, {
              x,
              y,
              w,
              h,
              fontSize: Math.max(1, element.fontSize),
              fontFace: fullFontName,
              color: textColor,
              transparency: 100 - textOpacity,
              bold: fontStyle.includes('Bold'),
              italic: fontStyle.includes('Italic'),
              align: convertTextAlign(element.textAlignHorizontal),
              valign: convertVerticalAlign(element.textAlignVertical),
              isTextBox: true,
              wrap: true,
              fit: 'shrink',
              name: element.name
            });
          }
          else if (element.type === 'SHAPE') {
            // 处理填充颜色
            let fillColor = 'FFFFFF';
            let fillOpacity = 100;
            if (element.fills && element.fills.length > 0) {
              const fill = element.fills[0];
              if (fill.type === 'SOLID') {
                fillColor = `${Math.round(fill.color.r * 255).toString(16).padStart(2, '0')}${Math.round(fill.color.g * 255).toString(16).padStart(2, '0')}${Math.round(fill.color.b * 255).toString(16).padStart(2, '0')}`;
                if ('opacity' in fill) {
                  fillOpacity = Math.round(fill.opacity * 100);
                }
              }
            }

            // 处理描边颜色
            let strokeColor = null;
            let strokeOpacity = 100;
            let strokeWidth = 0;
            if (element.strokes && element.strokes.length > 0) {
              const stroke = element.strokes[0];
              if (stroke.type === 'SOLID') {
                strokeColor = `${Math.round(stroke.color.r * 255).toString(16).padStart(2, '0')}${Math.round(stroke.color.g * 255).toString(16).padStart(2, '0')}${Math.round(stroke.color.b * 255).toString(16).padStart(2, '0')}`;
                if ('opacity' in stroke) {
                  strokeOpacity = Math.round(stroke.opacity * 100);
                }
                strokeWidth = element.strokeWeight || 0;
              }
            }

            const shapeOptions = {
              x,
              y,
              w,
              h,
              fill: { 
                color: fillColor,
                transparency: 100 - fillOpacity
              },
              line: strokeColor ? {
                color: strokeColor,
                transparency: 100 - strokeOpacity,
                pt: Math.max(0.25, strokeWidth),
                type: 'solid'
              } : undefined,
              name: element.name
            };

            if (element.cornerRadius) {
              shapeOptions.rectRadius = element.cornerRadius / 72;
            }

            slide.addShape(pptx.shapes.RECTANGLE, shapeOptions);
          }
          else if (element.type === 'IMAGE') {
            try {
              // 确保图片数据是有效的
              if (element.imageBytes && element.imageBytes.length > 0) {
                const imageBase64 = arrayBufferToBase64(element.imageBytes);
                
                // 添加图片到幻灯片
                slide.addImage({
                  data: `data:image/png;base64,${imageBase64}`,
                  x,
                  y,
                  w,
                  h,
                  sizing: {
                    type: 'contain',
                    w: w,
                    h: h
                  },
                  name: element.name // 保持图层名称
                });
              } else {
                console.warn(`Image data is missing for element: ${element.name}`);
              }
            } catch (error) {
              console.error('Error adding image:', error);
            }
          }
        }
      }
      
      await pptx.writeFile('FigmaExport.pptx');
    } catch (error) {
      console.error('PPT生成错误:', error);
      parent.postMessage({ pluginMessage: { type: 'error', message: '生成PPT时出错' } }, '*');
    }
  }
};

function arrayBufferToBase64(buffer) {
  let binary = '';
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
}

function convertTextAlign(figmaAlign) {
  const alignMap = {
    'LEFT': 'left',
    'CENTER': 'center',
    'RIGHT': 'right',
    'JUSTIFIED': 'justify'
  };
  return alignMap[figmaAlign] || 'left';
}

function convertVerticalAlign(figmaAlign) {
  const alignMap = {
    'TOP': 'top',
    'CENTER': 'middle',
    'BOTTOM': 'bottom'
  };
  return alignMap[figmaAlign] || 'top';
}

</script>
